# 2장 객체의 생성과 파괴

- 객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 법
- 올바른 객체 생성 방법과 불필요한 생성을 피하는 법
- 제때 파괴됨을 보장하고, 파괴 전에 수행해야 할 정리 작업을 관리하는 법

## 생성자 대신 정적 팩터리 메서드를 고려하라
클래스는 `public` 생성자 대신 **정적 팩터리 메서드**를 제공할 수 있습니다.

### 장점 5가지
1. **이름을 가질 수 있다**
    - 메서드명을 통해 반환될 객체의 특징을 쉽게 묘사할 수 있습니다.
2. **호출할 때마다 인스턴스를 새로 생성하지 않아도 된다**
    - 불필요한 객체 생성을 피할 수 있으며, 인스턴스를 언제 살아있게 할지 통제가 가능합니다.
3. **반환 타입의 하위 타입 객체를 반환할 수 있다**
    - 구현 클래스를 외부에 공개하지 않고도 객체를 반환할 수 있습니다.
4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다**
    - 반환 타입의 하위 타입 객체를 유연하게 반환할 수 있습니다.
5. **정적 팩터리 메소드 생성 시점에 반환할 객체의 클래스가 존재하지 않아도 된다**

### 단점 2가지
1. **상속을 제한한다**
    - 상속을 하려면 `public`이나 `protected` 생성자가 필요합니다. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없습니다.
2. **정적 팩터리 메서드는 찾기 어렵다**
    - 이 문제를 해결하기 위해 흔히 사용하는 명명 방식을 사용합니다.
        - `from`: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
        - `of`: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환
        - `instance` 혹은 `getInstance`: (매개변수가 있다면) 매개변수로 명시한 인스턴스를 반환

## 생성자에 매개변수가 많다면 빌더를 고려하라
- **선택적 매개변수**가 많다면 정적 팩터리와 생성자는 **점층적 생성자 패턴**을 사용할 수 있습니다. 하지만 매개변수가 많아지면 클라이언트 코드 작성과 이해가 어려워질 수 있습니다.
- **자바빈즈 패턴**: 세터 메서드를 통해 값을 설정하는 방식이지만, 일관성이 깨지고 객체를 불변으로 만들 수 없습니다.
- **빌더 패턴**: 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자(또는 정적 팩터리)를 호출해 **빌더 객체**를 얻습니다. 이후 빌더 객체의 메서드를 통해 매개변수를 설정한 뒤 `build()` 메서드로 **불변 객체**를 생성합니다.

## private 생성자나 열거 타입으로 싱글턴임을 보증하라
**싱글턴**이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 그러나 싱글턴으로 만들면 테스트가 어려워질 수 있습니다.

싱글턴 패턴의 구현 방법:
1. **public static 필드 방식**
    - 더 간단하고 명확합니다. 싱글턴임이 명백하게 드러납니다.
2. **정적 팩터리 메서드 방식**
    - 유연성이 필요할 때 유리합니다. 나중에 싱글턴이 아니게 될 가능성이 있을 때, 제네릭 사용, 메서드 참조 등을 지원하기 좋습니다.
3. **원소가 하나인 열거 타입으로 선언**
    - 더 간결하며, 추가 노력 없이 직렬화가 가능하고 리플렉션 공격에도 안전합니다.

## 인스턴스화를 막으려거든 private 생성자를 사용하라
- 단순히 **정적 메서드와 정적 필드**만을 담은 클래스를 만들고 싶을 때가 있습니다.
- 생성자를 명시하지 않으면 컴파일러가 자동으로 **기본 생성자**를 생성하며, 이는 외부에서 인스턴스화를 허용합니다.
- 추상 클래스로 만들어도 하위 클래스를 통해 인스턴스화가 가능합니다.
- 인스턴스화를 막는 방법은 **생성자를 `private`으로 선언**하는 것입니다.

## 자원을 직접 명시하지 말고 의존 객체 주입 사용하라
- 많은 클래스가 하나 이상의 자원에 의존합니다.
- 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다면, 인스턴스를 생성할 때 **생성자에 필요한 자원**을 넘겨줍니다.

## 불필요한 객체 생성을 피하라
- 똑같은 기능의 객체를 매번 생성하기보다는 **객체 하나를 재사용**하는 편이 좋습니다.
- **정적 팩터리 메서드**를 제공하는 불변 클래스에서 불필요한 객체 생성을 피할 수 있습니다.
- 예를 들어, `Boolean(String)` 생성자 대신 **`Boolean.valueOf(String)`**를 사용하는 것이 좋습니다.


## 다 쓴 객체 참조를 해제하라

자바는 **가비지 컬렉터**를 갖추고 있어 메모리 관리가 자동으로 이뤄지지만, 이는 메모리 관리에 완전히 신경 쓰지 않아도 된다는 의미는 아닙니다. 잘못 사용하면 여전히 **메모리 누수**가 발생할 수 있습니다.

### 1. 메모리 누수가 발생하는 이유
- **스택의 메모리 관리**: 스택이 커졌다가 줄어들었을 때, 스택에서 꺼낸 객체들이 가비지 컬렉터에 의해 회수되지 않습니다. 이는 스택이 그 객체들의 **다 쓴 참조(obsolete reference)**를 여전히 가지고 있기 때문입니다.
- 이러한 다 쓴 참조는 **앞으로 다시 쓰지 않을 참조**를 의미합니다. 예를 들어, 스택의 **활성 영역**(현재 사용 중인 영역) 외부의 객체는 더 이상 필요 없지만 여전히 참조가 남아 있는 상태입니다.

### 2. 해결 방법: 참조 해제하기
- **null 처리**: 해당 참조를 더 이상 사용하지 않을 때 **null로 설정**하여 참조를 해제합니다.
- 예를 들어, 스택에서 객체를 꺼낼 때(`pop()`), 꺼낸 객체의 참조를 `null`로 설정하면 가비지 컬렉터가 해당 객체를 회수할 수 있습니다.

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}
```

### 3. null 처리의 이점
- **NullPointerException 예방**: 다 쓴 참조를 `null`로 설정하면 실수로 해당 참조를 다시 사용하려 할 때 즉시 `NullPointerException`을 던집니다. 이는 프로그램 오류를 빠르게 발견하는 데 도움이 됩니다.

### 4. 언제 null 처리를 해야 하는가?
- 모든 객체를 **일일이 null 처리**할 필요는 없습니다. **객체 참조를 관리하는 클래스**(예: 직접 메모리를 관리하는 스택, 캐시 등)를 구현할 때에만 주의하면 됩니다.
- 다 쓴 참조를 해제하는 가장 좋은 방법은 변수의 유효 범위(scope)를 최소화하는 것입니다.

### 5. 메모리 누수가 자주 발생하는 사례
- **캐시**: 사용이 끝난 객체가 캐시에 남아 있으면 메모리 누수가 발생합니다. 이를 방지하기 위해 약한 참조(Weak Reference)나 **정기적인 캐시 청소** 기법을 사용할 수 있습니다.
- **리스너 혹은 콜백**: 리스너를 등록하고 해지하지 않는다면, 계속 메모리를 차지하게 되어 누수가 발생합니다. 이를 방지하기 위해 **약한 참조(Weak Reference)**로 관리하면, 가비지 컬렉터가 참조되지 않은 콜백을 회수할 수 있습니다.
